---
title: 设计模式
date: 2018-03-27  
tags: design pattern
---
#### 什么是设计模式
  设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一切问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。
  GOF四人帮提出的设计模式主要是基于以下的面向对象设计原则：
  1.对接口编程而不是对实现编程
  2.优先使用对象组合而不是继承
<!-- more -->
  
  设计模式可以分为三大类：创建型模式（工厂模式/抽象工厂模式/单例模式/建造者模式/原型模式）、结构型模式（适配型模式/桥接模式/过滤器模式/组合模式/装饰器模式/外观模式/享元模式/代理模式）、行为型模式（责任链模式/命令模式/解释器模式/迭代器模式/终结者模式/备忘录模式/观察者模式/状态模式/空对象模式/策略模式/模板模式/访问者模式）、J2EE模式（MVC模式/业务代表模式/组合实体模式/数据访问对象模式/前端控制器模式/拦截过滤器模式/服务定位器模式/传输对象模式）。
  - 创建型模式-->对象怎么来
  - 结构型模式-->对象和谁有关
  - 行为型模式-->对象和对象在干嘛
  - J2EE模式-->对象合起来要干嘛
  
#### 设计模式的六大原则
1.开闭原则(实现热插拔，提高扩展性)
  开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能无修改原有的代码，实现一个热插拔的效果。简而言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。
  
2.里式代换原则（实现抽象的规范，实现子父类相互替换）
  里式代换原则是面向对象设计的基本原则之一。任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当子类(派生类)可以替换掉基类，且软件单位的功能不收到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里式代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现。
简单的理解为一个软件实体如果使用的是一个父类，那么一定适用于其子类，而且他察觉不出父类对象和子类对象的区别。也就是说，软件里面，把父类都替换成它的子类，程序的行为没有变化。
  
 3.依赖倒转原则（针对接口编程，实现开闭原则的基础）
   这个原则是开闭原则的基础，具体内容，针对接口编程，依赖于抽象不依赖于具体。
   
 4.接口隔离原则（降低耦合度，接口单独设计，互相隔离）
   使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是，降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发，便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
   
 5.迪米特法则，又称最少知道原则（功能模块尽量独立）
   最少知道原则是指，一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
   
 6.合成复用原则（尽量使用聚合，组合，而不是继承）
   此原则讲的是：尽量使用合成/聚合的方式，而不是使用继承。
   
#### 创建者模式·工厂模式
- 意图:定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
- 主要解决：接口选择的问题。
- 何时使用：我们明确地计划不同条件下创建不同实例时
- 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品
- 关键代码：创建过程让其子类执行
- 优点：
  + 一个调用者想创建对象，只要知道其名称就可以了。
  + 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
  + 屏蔽产品的具体实现，调用者只关心产品的接口。
- 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加。
- 使用场景：
  + 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
  + 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。
- 实现
  <img src="http://oo8ieb5e5.bkt.clouddn.com/image/vps/factory_design_pattern.jpg" align="center" />
  
#### 创建者模式·单例模式
  这种模式设计到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问们不需要实例化该类的对象。  
  注意：  
    1.单例类只能有一个实例。  
    2.单例类必须自己创建自己唯一的实例  
    3.单例类必须给所有其他对象提供这一实例
   
- 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点
- 主要解决：一个全局使用的类频繁地创建与销毁
- 何时使用：当你想控制实例数目，节省系统资源的时候
- 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建
- 关键代码：构造函数是私有的
- 应用实例：
  + windows是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
  + 一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。
- 优点：
  + 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例
  + 避免对资源的多重占用(比如写文件的操作)
- 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化
- 使用场景：
  + 要求生成唯一序列号
  + WEB中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
  + 创建的一个对象需要消耗的资源过多，比如I/O与数据库的连接等
- 实现：
<img src="http://oo8ieb5e5.bkt.clouddn.com/image/vps/singleton_pattern_uml_diagram.jpg" align="center" />

#### 创建者模式·建造者模式
  建造者模式使用多个简单的对象一步一步构建成一个复杂的对象，它提供了一种创建对象的最佳方式。
  
- 意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的标识。
- 主要解决：主要解决在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成，由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将他们组合在一起的算法却相对稳定
- 何时使用：一些基本不见不会变，而其组合经常变化的时候
- 关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系
- 应用实例：
  + 去金拱门，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成了所谓的“套餐”
  + JAVA中的StringBuilder
- 优点：
  + 建造者独立，易扩展
  + 便于控制细节风险
- 缺点：
  + 产品必须有共同点，范围有限制
  + 如内部变化复杂，会有很多的建造类
- 使用场景
  + 需要生成的对象具有复杂的内部结构
  + 需要生成的对象内部属性本身相互依赖

#### 结构型模式·适配器模式
  将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
  
- 主要解决：在软件系统中，常常要将一些“现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。
- 何时使用：
  + 系统需要使用现有的类，而此类的接口不符合系统的需要。
  + 想要建立一个可以重复使用的类，用于与一些彼此没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定要有一直的接口
  + 通过接口转换，将一个类插入另一个类系中
- 如何解决：继承或依赖
- 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口
- 应用实例：
  + 在Linux上运行Windows程序
  + JAVA中的jdbc
- 优点：
  + 可以让任何两个没有关联的类一起运行
  + 提高了类的复用
  + 增加了类的透明度
  + 灵活性好
- 缺点：
  + 过多的使用适配器，会让系统非常零乱，不易整体把握
  + 由于JAVA至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类
- 使用场景：有动机的修改一个正常运行的系统的接口，这是应该考虑使用适配器模式
- 注意事项：适配器不是在详细设计的时候添加的，而是解决正在服役的项目的问题

#### J2EE模式·MVC模式  
  MVC模式代表Model-View-Controller(模型-视图-控制器)模式，这种模式用于应用程序的分层开发。  
- Model：模式代表一个存取数据的对象或JAVA POJO。它可以带有逻辑，在数据变化时更新控制器
- View：视图代表模型包含的数据的可视化
- Controller：控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。他使视图和模型分离开

#### J2EE模式·前端控制器模式
  前端控制器模式是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理，该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。
  1.前端控制器：处理应用程序所有类型请求的单个处理程序，应用程序可以是基于web的应用程序，也可以是基于桌面的应用程序
  2.调度器：前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序
  3.视图：视图是为请求而创建的对象

更多设计模式详情：http://www.runoob.com/design-pattern/adapter-pattern.html