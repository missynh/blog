---
title: 设计模式
date: 2018-03-27  
tags: design pattern
---
#### 什么是设计模式
  设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一切问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。
  GOF四人帮提出的设计模式主要是基于以下的面向对象设计原则：
  1.对接口编程而不是对实现编程
  2.优先使用对象组合而不是继承
  
  设计模式可以分为三大类：创建型模式（工厂模式/抽象工厂模式/单例模式/建造者模式/原型模式）、结构型模式（适配型模式/桥接模式/过滤器模式/组合模式/装饰器模式/外观模式/享元模式/代理模式）、行为型模式（责任链模式/命令模式/解释器模式/迭代器模式/终结者模式/备忘录模式/观察者模式/状态模式/空对象模式/策略模式/模板模式/访问者模式）、J2EE模式（MVC模式/业务代表模式/组合实体模式/数据访问对象模式/前端控制器模式/拦截过滤器模式/服务定位器模式/传输对象模式）。
  创建型模式-->对象怎么来
  结构型模式-->对象和谁有关
  行为型模式-->对象和对象在干嘛
  J2EE模式-->对象合起来要干嘛
  
#### 设计模式的六大原则
1.开闭原则(实现热插拔，提高扩展性)
  开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能无修改原有的代码，实现一个热插拔的效果。简而言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。
  
2.里式代换原则（实现抽象的规范，实现子父类相互替换）
  里式代换原则是面向对象设计的基本原则之一。任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当子类(派生类)可以替换掉基类，且软件单位的功能不收到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里式代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现。
简单的理解为一个软件实体如果使用的是一个父类，那么一定适用于其子类，而且他察觉不出父类对象和子类对象的区别。也就是说，软件里面，把父类都替换成它的子类，程序的行为没有变化。
  
 3.依赖倒转原则（针对接口编程，实现开闭原则的基础）
   这个原则是开闭原则的基础，具体内容，针对接口编程，依赖于抽象不依赖于具体。
   
 4.接口隔离原则（降低耦合度，接口单独设计，互相隔离）
   使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是，降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发，便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
   
 5.迪米特法则，又称最少知道原则（功能模块尽量独立）
   最少知道原则是指，一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
   
 6.合成复用原则（尽量使用聚合，组合，而不是继承）
   此原则讲的是：尽量使用合成/聚合的方式，而不是使用继承。
   
#### 工厂模式
- 意图:定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
- 主要解决：接口选择的问题。
- 何时使用：我们明确地计划不同条件下创建不同实例时
- 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品
- 关键代码：创建过程让其子类执行
- 优点：
  + 一个调用者想创建对象，只要知道其名称就可以了。
  + 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
  + 屏蔽产品的具体实现，调用者只关心产品的接口。
- 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加。
- 使用场景：
  + 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
  + 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。
- 实现
  <img src="http://oo8ieb5e5.bkt.clouddn.com/image/vps/factory_design_pattern.jpg" align="center" />
  
#### 单例模式
  这种模式设计到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问们不需要实例化该类的对象。  
  注意：  
    1.单例类只能有一个实例。  
    2.单例类必须自己创建自己唯一的实例  
    3.单例类必须给所有其他对象提供这一实例
   
- 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点
- 主要解决：一个全局使用的类频繁地创建与销毁
- 何时使用：当你想控制实例数目，节省系统资源的时候
- 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建
- 关键代码：构造函数是私有的
- 应用实例：
  + windows是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
  + 一些设备管理器常常设计为单例模式，比如一个电脑有两台答应机，在输出的时候就要处理不能两台打印机打印同一个文件。
- 优点：
  + 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例
  + 避免对资源的多重占用(比如写文件的操作)
- 缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化
- 使用场景：
  + 要求生成唯一序列号
  + WEB中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
  + 创建的一个对象需要消耗的资源过多，比如I/O与数据库的连接等
- 实现：
<img src="http://oo8ieb5e5.bkt.clouddn.com/image/vps/singleton_pattern_uml_diagram.jpg" align="center" />